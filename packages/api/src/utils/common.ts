/**
 * Groups an array of objects based on a key generated by the keyFn.
 * The key is serialized using the serializerFn.
 *
 * @param arr The array of objects to group
 * @param keyFn A function that generates a key for each object
 * @param serializerFn A function that serializes the key (optional)
 * @returns An object with keys as the serialized group keys and values as arrays of objects
 */
export function groupBy<T, K>(
    arr: T[],
    keyFn: (item: T) => K,
    serializerFn: (key: K) => string = JSON.stringify,
): Record<string, T[]> {
    return arr.reduce(
        (acc, item) => {
            const key = serializerFn(keyFn(item));
            if (!acc[key]) {
                acc[key] = [];
            }
            acc[key].push(item);
            return acc;
        },
        {} as Record<string, T[]>,
    );
}

/**
 * Exists solely to enable mocking of functions that use current date.
 * @returns A date object representing now
 */
export function getDateNow(): Date {
    return new Date();
}

function getUniqueSet<T, X extends string>(
    things: T[],
    getUniqueKey: (thing: T) => X,
): [[X, T][], Set<X>] {
    const mappedKeys: [X, T][] = things.map((thing) => [
        getUniqueKey(thing),
        thing,
    ]);

    const setOfUniqueKeys = new Set<X>(mappedKeys.map(([key]) => key));
    if (setOfUniqueKeys.size !== mappedKeys.length) {
        throw new Error("Data had duplicate keys which should be unique");
    }
    return [mappedKeys, setOfUniqueKeys];
}

function set1NotInSet2<T>(set1: Set<T>, set2: Set<T>) {
    return new Set([...set1].filter((key) => !set2.has(key)));
}

export function getNewThings<T, X extends string>(
    existingThings: T[],
    maybeNewThings: T[],
    getUniqueKey: (thing: T) => X,
): T[] {
    const [_existingKeys, existingKeysSet] = getUniqueSet(
        existingThings,
        getUniqueKey,
    );

    const [maybeNewKeys, maybeNewKeysSet] = getUniqueSet(
        maybeNewThings,
        getUniqueKey,
    );

    const newKeys = set1NotInSet2(maybeNewKeysSet, existingKeysSet);

    return maybeNewKeys
        .filter(([key]) => newKeys.has(key))
        .map(([_key, thing]) => thing);
}

function pascalCaseToCamelCase(str: string): string {
    if (!str[0]) {
        return str;
    }
    const copy = [...str];
    copy[0] = str[0].toLowerCase();
    return copy.join("");
}

function camelCaseToPascalCase(str: string): string {
    if (!str[0]) {
        return str;
    }
    const copy = [...str];
    copy[0] = str[0].toUpperCase();
    return copy.join("");
}


export function keysToObject<K extends string, V>(
    keys: K[],
    getValue: (key: K) => V,
): Record<K, V> {
    return keys.reduce(
        (acc, key) => {
            acc[key] = getValue(key);
            return acc;
        },
        {} as Record<K, V>,
    );
}
